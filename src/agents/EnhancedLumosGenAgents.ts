/**
 * Enhanced LumosGen Agents with Advanced Context Engineering
 * 
 * These agents leverage the new context engineering system for superior
 * content generation with intelligent document selection and processing.
 */

import { BaseAgent, AgentResult, AgentContext } from './simple-agent-system';
import { EnhancedProjectAnalyzer, EnhancedProjectAnalysis } from '../analysis/EnhancedProjectAnalyzer';
import { ContextSelector, AITaskType, SelectedContext } from '../analysis/ContextSelector';
import * as vscode from 'vscode';

// üîç Â¢ûÂº∫È°πÁõÆÁõëÊéßAgent
export class EnhancedProjectWatcherAgent extends BaseAgent {
    private analyzer: EnhancedProjectAnalyzer;
    private contextSelector: ContextSelector;
    
    constructor(workspaceRoot: string, outputChannel: vscode.OutputChannel) {
        super(
            'EnhancedProjectWatcher',
            'Advanced Project Monitor',
            'Analyze project changes with comprehensive context understanding',
            `Expert in deep project analysis using advanced context engineering.
            Leverages all available documentation, code structure, and project metadata
            to provide comprehensive insights for marketing content generation.`
        );
        
        this.analyzer = new EnhancedProjectAnalyzer(workspaceRoot, outputChannel);
        this.contextSelector = new ContextSelector();
    }

    async execute(input: any, context: AgentContext): Promise<AgentResult> {
        try {
            const { projectPath, changedFiles, strategy = 'balanced' } = input;
            
            // ÊâßË°åÂ¢ûÂº∫È°πÁõÆÂàÜÊûê
            const analysis = await this.analyzer.analyzeProjectEnhanced(strategy);
            
            // ‰∏∫È°πÁõÆÂàÜÊûê‰ªªÂä°ÈÄâÊã©ÊúÄ‰Ω≥‰∏ä‰∏ãÊñá
            const selectedContext = this.contextSelector.selectContext(analysis, 'project-analysis');
            
            // ÁîüÊàêÂ¢ûÂº∫ÁöÑÂàÜÊûêÊèêÁ§∫
            const prompt = this.generateEnhancedAnalysisPrompt(analysis, selectedContext, changedFiles);
            
            const response = await this.callLLM(prompt, context);
            const enhancedAnalysis = this.parseEnhancedAnalysis(response, analysis, selectedContext);
            
            return {
                success: true,
                data: enhancedAnalysis,
                metadata: {
                    executionTime: 0,
                    confidence: this.calculateEnhancedConfidence(enhancedAnalysis),
                    contextStrategy: strategy,
                    documentsAnalyzed: selectedContext.selectedFiles.length,
                    totalTokens: selectedContext.totalTokens
                }
            };
            
        } catch (error) {
            return {
                success: false,
                data: null,
                error: error instanceof Error ? error.message : 'Enhanced project analysis failed'
            };
        }
    }
    
    private generateEnhancedAnalysisPrompt(
        analysis: EnhancedProjectAnalysis, 
        selectedContext: SelectedContext, 
        changedFiles: string[]
    ): string {
        const structuredData = selectedContext.structured;
        const documentContext = selectedContext.selectedFiles
            .map(file => `## ${file.path}\n${file.content}`)
            .join('\n\n');
        
        return `
# Â¢ûÂº∫È°πÁõÆÂàÜÊûê‰ªªÂä°

## È°πÁõÆÁªìÊûÑÂåñ‰ø°ÊÅØ
**È°πÁõÆÂêçÁß∞**: ${structuredData?.metadata.name}
**ÊèèËø∞**: ${structuredData?.metadata.description}
**ÊäÄÊúØÊ†à**: ${structuredData?.techStack.map(t => `${t.language}${t.framework ? ` (${t.framework})` : ''}`).join(', ')}
**‰æùËµñÊï∞Èáè**: ${structuredData?.dependencies.length || 0}
**ËÑöÊú¨Êï∞Èáè**: ${structuredData?.scripts.length || 0}

## ÂèòÊõ¥Êñá‰ª∂
${Array.isArray(changedFiles) ? changedFiles.join('\n') : (changedFiles || 'Êó†ÁâπÂÆöÂèòÊõ¥Êñá‰ª∂')}

## ÊñáÊ°£‰∏ä‰∏ãÊñá (${selectedContext.selectedFiles.length}‰∏™ÊñáÊ°£, ${selectedContext.totalTokens} tokens)
${selectedContext.selectionReason}

${documentContext}

## ÂàÜÊûêË¶ÅÊ±Ç
Âü∫‰∫é‰ª•‰∏äÂÆåÊï¥ÁöÑÈ°πÁõÆ‰ø°ÊÅØÂíåÊñáÊ°£‰∏ä‰∏ãÊñáÔºåËØ∑Êèê‰æõÔºö

1. **È°πÁõÆÁâπÊÄßÂàÜÊûê**
   - Ê†∏ÂøÉÂäüËÉΩÂíå‰ª∑ÂÄº‰∏ªÂº†
   - ÊäÄÊúØÂàõÊñ∞ÁÇπÂíåÁ´û‰∫â‰ºòÂäø
   - ÁõÆÊ†áÁî®Êà∑Áæ§‰ΩìÂÆö‰Ωç

2. **ÂèòÊõ¥ÂΩ±ÂìçËØÑ‰º∞**
   - ÂèòÊõ¥Á±ªÂûãÂíåÈáçË¶ÅÊÄßÁ∫ßÂà´
   - ÂØπËê•ÈîÄÂÜÖÂÆπÁöÑÂΩ±ÂìçÁ®ãÂ∫¶
   - ÈúÄË¶ÅÊõ¥Êñ∞ÁöÑÂÜÖÂÆπÂå∫Âüü

3. **Ëê•ÈîÄÊú∫‰ºöËØÜÂà´**
   - ÂèØÁ™ÅÂá∫ÁöÑÊäÄÊúØ‰∫ÆÁÇπ
   - Áî®Êà∑ÁóõÁÇπËß£ÂÜ≥ÊñπÊ°à
   - Â∏ÇÂú∫ÂÆö‰ΩçÂª∫ËÆÆ

4. **ÂÜÖÂÆπÁ≠ñÁï•Âª∫ËÆÆ**
   - ‰ºòÂÖàÁ∫ßÊéíÂ∫èÁöÑÂÜÖÂÆπÊõ¥Êñ∞ËÆ°Âàí
   - ÁõÆÊ†áÂèó‰ºóÁöÑÊ≤üÈÄöÁ≠ñÁï•
   - SEOÂíåËΩ¨Âåñ‰ºòÂåñÂª∫ËÆÆ

ËØ∑Êèê‰æõÁªìÊûÑÂåñ„ÄÅÂèØÊâßË°åÁöÑÂàÜÊûêÁªìÊûú„ÄÇ
`;
    }
    
    private parseEnhancedAnalysis(response: string, analysis: EnhancedProjectAnalysis, context: SelectedContext): any {
        return {
            // Âü∫Á°ÄÂàÜÊûêÁªìÊûú
            projectFeatures: this.extractProjectFeatures(response),
            changeImpact: this.extractChangeImpact(response),
            marketingOpportunities: this.extractMarketingOpportunities(response),
            contentStrategy: this.extractContentStrategy(response),
            
            // Â¢ûÂº∫‰ø°ÊÅØ
            enhancedContext: {
                documentsAnalyzed: context.selectedFiles.length,
                totalTokens: context.totalTokens,
                contextStrategy: context.strategy.taskType,
                documentCategories: this.getDocumentCategories(context.selectedFiles)
            },
            
            // È°πÁõÆÊ¥ûÂØü
            projectInsights: {
                techStackComplexity: this.calculateTechStackComplexity(analysis.structured.techStack),
                documentationQuality: this.assessDocumentationQuality(analysis.fullText),
                marketingReadiness: this.assessMarketingReadiness(analysis)
            },
            
            // ÂéüÂßãÊï∞ÊçÆ
            rawAnalysis: response,
            fullProjectAnalysis: analysis
        };
    }
    
    private extractProjectFeatures(text: string): string[] {
        const section = this.extractSection(text, 'È°πÁõÆÁâπÊÄßÂàÜÊûê');
        return this.extractListItems(section);
    }
    
    private extractChangeImpact(text: string): any {
        const section = this.extractSection(text, 'ÂèòÊõ¥ÂΩ±ÂìçËØÑ‰º∞');
        return {
            changeType: this.extractValue(section, 'ÂèòÊõ¥Á±ªÂûã'),
            impactLevel: this.extractValue(section, 'ÈáçË¶ÅÊÄßÁ∫ßÂà´'),
            affectedAreas: this.extractListItems(section)
        };
    }
    
    private extractMarketingOpportunities(text: string): string[] {
        const section = this.extractSection(text, 'Ëê•ÈîÄÊú∫‰ºöËØÜÂà´');
        return this.extractListItems(section);
    }
    
    private extractContentStrategy(text: string): any {
        const section = this.extractSection(text, 'ÂÜÖÂÆπÁ≠ñÁï•Âª∫ËÆÆ');
        return {
            priorities: this.extractListItems(section),
            recommendations: this.extractListItems(section)
        };
    }
    
    private extractSection(text: string, sectionName: string): string {
        const regex = new RegExp(`${sectionName}[\\s\\S]*?(?=\\n##|$)`, 'i');
        const match = text.match(regex);
        return match ? match[0] : '';
    }
    
    private extractListItems(text: string): string[] {
        const lines = text.split('\n');
        return lines
            .filter(line => line.trim().match(/^[-*‚Ä¢]\s+/))
            .map(line => line.replace(/^[-*‚Ä¢]\s+/, '').trim())
            .filter(item => item.length > 0);
    }
    
    private extractValue(text: string, key: string): string {
        const regex = new RegExp(`${key}[Ôºö:][\\s]*([^\\n]+)`, 'i');
        const match = text.match(regex);
        return match ? match[1].trim() : '';
    }
    
    private getDocumentCategories(files: any[]): Record<string, number> {
        const categories: Record<string, number> = {};
        files.forEach(file => {
            categories[file.category] = (categories[file.category] || 0) + 1;
        });
        return categories;
    }
    
    private calculateTechStackComplexity(techStack: any[]): number {
        // Âü∫‰∫éÊäÄÊúØÊ†àÊï∞ÈáèÂíåÁ±ªÂûãËÆ°ÁÆóÂ§çÊùÇÂ∫¶
        const uniqueLanguages = new Set(techStack.map(t => t.language)).size;
        const frameworkCount = techStack.filter(t => t.framework).length;
        return Math.min(100, (uniqueLanguages * 20) + (frameworkCount * 15));
    }
    
    private assessDocumentationQuality(fullText: any): number {
        const { allMarkdownFiles, averagePriority } = fullText;
        const docCount = allMarkdownFiles.length;
        const avgPriority = averagePriority || 0;
        
        // Âü∫‰∫éÊñáÊ°£Êï∞ÈáèÂíåÂπ≥Âùá‰ºòÂÖàÁ∫ßËØÑ‰º∞Ë¥®Èáè
        let quality = Math.min(50, docCount * 5); // ÊñáÊ°£Êï∞ÈáèË¥°ÁåÆ
        quality += Math.min(50, avgPriority); // ‰ºòÂÖàÁ∫ßË¥°ÁåÆ
        
        return Math.round(quality);
    }
    
    private assessMarketingReadiness(analysis: EnhancedProjectAnalysis): number {
        let readiness = 0;
        
        // Âü∫Á°Ä‰ø°ÊÅØÂÆåÊï¥ÊÄß
        if (analysis.structured.metadata.description) readiness += 20;
        if (analysis.structured.metadata.keywords.length > 0) readiness += 10;
        
        // ÊñáÊ°£ÂÆåÊï¥ÊÄß
        if (analysis.semiStructured.readme) readiness += 30;
        if (analysis.semiStructured.changelog) readiness += 10;
        if (analysis.semiStructured.userGuide) readiness += 15;
        
        // ÊäÄÊúØÊ†àÊ∏ÖÊô∞Â∫¶
        if (analysis.structured.techStack.length > 0) readiness += 15;
        
        return Math.min(100, readiness);
    }
    
    private calculateEnhancedConfidence(analysis: any): number {
        let confidence = 60; // Âü∫Á°ÄÁΩÆ‰ø°Â∫¶
        
        // Âü∫‰∫éÂàÜÊûêÊ∑±Â∫¶
        if (analysis.projectFeatures.length > 3) confidence += 15;
        if (analysis.marketingOpportunities.length > 2) confidence += 10;
        if (analysis.enhancedContext.documentsAnalyzed > 5) confidence += 10;
        if (analysis.projectInsights.documentationQuality > 70) confidence += 5;
        
        return Math.min(95, confidence);
    }
}

// üìä Â¢ûÂº∫ÂÜÖÂÆπÂàÜÊûêAgent
export class EnhancedContentAnalyzerAgent extends BaseAgent {
    private contextSelector: ContextSelector;

    constructor() {
        super(
            'EnhancedContentAnalyzer',
            'Advanced Content Strategy Analyst',
            'Create sophisticated content strategies using comprehensive project context',
            `Expert content strategist with access to complete project documentation.
            Leverages advanced context engineering to identify content gaps, opportunities,
            and create data-driven content strategies for technical audiences.`
        );

        this.contextSelector = new ContextSelector();
    }

    async execute(input: any, context: AgentContext): Promise<AgentResult> {
        try {
            const { projectAnalysis, existingContent, targetAudience, contentType = 'marketing-content' } = input;

            // ÈÄâÊã©ÈÄÇÂêàÂÜÖÂÆπÂàÜÊûêÁöÑ‰∏ä‰∏ãÊñá
            const selectedContext = this.contextSelector.selectContext(projectAnalysis, contentType as AITaskType);

            // ÁîüÊàêÂ¢ûÂº∫ÁöÑÂÜÖÂÆπÁ≠ñÁï•ÊèêÁ§∫
            const prompt = this.generateContentStrategyPrompt(projectAnalysis, selectedContext, existingContent, targetAudience);

            const response = await this.callLLM(prompt, context);
            const strategy = this.parseEnhancedContentStrategy(response, selectedContext);

            return {
                success: true,
                data: strategy,
                metadata: {
                    executionTime: 0,
                    confidence: this.calculateStrategyConfidence(strategy),
                    contextDocuments: selectedContext.selectedFiles.length,
                    totalTokens: selectedContext.totalTokens,
                    taskType: contentType
                }
            };

        } catch (error) {
            return {
                success: false,
                data: null,
                error: error instanceof Error ? error.message : 'Enhanced content analysis failed'
            };
        }
    }

    private generateContentStrategyPrompt(
        projectAnalysis: EnhancedProjectAnalysis,
        selectedContext: SelectedContext,
        existingContent: string,
        targetAudience: string
    ): string {
        const documentContext = selectedContext.selectedFiles
            .map(file => `### ${file.category.toUpperCase()}: ${file.path}\n${file.content.substring(0, 1000)}${file.content.length > 1000 ? '...' : ''}`)
            .join('\n\n');

        return `
# Â¢ûÂº∫ÂÜÖÂÆπÁ≠ñÁï•ÂàÜÊûê

## È°πÁõÆÊ¶ÇËßà
**ÂêçÁß∞**: ${projectAnalysis.structured.metadata.name}
**ÊèèËø∞**: ${projectAnalysis.structured.metadata.description}
**ÊäÄÊúØÊ†à**: ${projectAnalysis.structured.techStack.map(t => t.language).join(', ')}
**ÁõÆÊ†áÂèó‰ºó**: ${targetAudience}

## Áé∞ÊúâÂÜÖÂÆπÂàÜÊûê
${existingContent || 'ÊöÇÊó†Áé∞ÊúâÂÜÖÂÆπ'}

## È°πÁõÆÊñáÊ°£‰∏ä‰∏ãÊñá (${selectedContext.selectedFiles.length}‰∏™ÊñáÊ°£)
${selectedContext.selectionReason}

${documentContext}

## ÂÜÖÂÆπÁ≠ñÁï•Ë¶ÅÊ±Ç

Âü∫‰∫éÂÆåÊï¥ÁöÑÈ°πÁõÆ‰ø°ÊÅØÂíåÊñáÊ°£ÂàÜÊûêÔºåËØ∑Âà∂ÂÆöÔºö

### 1. ÂÜÖÂÆπÂ∑ÆË∑ùÂàÜÊûê
- ËØÜÂà´ÂΩìÂâçÂÜÖÂÆπÁöÑ‰∏çË∂≥‰πãÂ§Ñ
- ÂàÜÊûêÁ´û‰∫âÂØπÊâãÂèØËÉΩÁöÑ‰ºòÂäø
- Á°ÆÂÆöÊÄ•ÈúÄË°•ÂÖÖÁöÑÂÜÖÂÆπÁ±ªÂûã

### 2. ÂÜÖÂÆπ‰ºòÂÖàÁ∫ßÁü©Èòµ
- È´òÂΩ±ÂìçÂäõ„ÄÅ‰ΩéÊàêÊú¨ÁöÑÂø´ÈÄüËÉúÂà©ÂÜÖÂÆπ
- È´òÂΩ±ÂìçÂäõ„ÄÅÈ´òÊàêÊú¨ÁöÑÊàòÁï•ÊÄßÂÜÖÂÆπ
- ÂÜÖÂÆπÊõ¥Êñ∞ÁöÑÊó∂Èó¥Á∫øÂª∫ËÆÆ

### 3. Âèó‰ºóÁªÜÂàÜÁ≠ñÁï•
- ‰∏ªË¶ÅÂèó‰ºóÁæ§‰ΩìÁâπÂæÅÂàÜÊûê
- ‰∏çÂêåÂèó‰ºóÁöÑÂÜÖÂÆπÂÅèÂ•Ω
- ‰∏™ÊÄßÂåñÂÜÖÂÆπÂª∫ËÆÆ

### 4. SEOÂíåÂèëÁé∞ÊÄß‰ºòÂåñ
- ÂÖ≥ÈîÆËØçÊú∫‰ºöËØÜÂà´
- ÂÜÖÂÆπÁªìÊûÑ‰ºòÂåñÂª∫ËÆÆ
- ÊêúÁ¥¢ÊÑèÂõæÂåπÈÖçÁ≠ñÁï•

### 5. ËΩ¨ÂåñË∑ØÂæÑËÆæËÆ°
- Áî®Êà∑ÊóÖÁ®ãÊò†Â∞Ñ
- ÂÜÖÂÆπÊºèÊñóËÆæËÆ°
- CTAÁ≠ñÁï•Âíå‰ΩçÁΩÆÂª∫ËÆÆ

### 6. ÂÜÖÂÆπÊ†ºÂºèÂíåÊ∏†ÈÅìÁ≠ñÁï•
- ÊúÄÈÄÇÂêàÁöÑÂÜÖÂÆπÊ†ºÂºè
- ÂàÜÂèëÊ∏†ÈÅìÂª∫ËÆÆ
- Ë∑®Âπ≥Âè∞ÂÜÖÂÆπÈÄÇÈÖç

ËØ∑Êèê‰æõÂÖ∑‰Ωì„ÄÅÂèØÊâßË°åÁöÑÁ≠ñÁï•Âª∫ËÆÆ„ÄÇ
`;
    }

    private parseEnhancedContentStrategy(response: string, context: SelectedContext): any {
        return {
            // Ê†∏ÂøÉÁ≠ñÁï•ÁªÑ‰ª∂
            contentGaps: this.extractContentGaps(response),
            priorityMatrix: this.extractPriorityMatrix(response),
            audienceSegmentation: this.extractAudienceSegmentation(response),
            seoStrategy: this.extractSEOStrategy(response),
            conversionPath: this.extractConversionPath(response),
            contentFormats: this.extractContentFormats(response),

            // Â¢ûÂº∫ÂàÜÊûê
            contextInsights: {
                documentTypes: this.analyzeDocumentTypes(context.selectedFiles),
                contentQuality: this.assessContentQuality(context.selectedFiles),
                technicalDepth: this.assessTechnicalDepth(context.selectedFiles)
            },

            // ÊâßË°åÂª∫ËÆÆ
            actionPlan: this.generateActionPlan(response),
            timeline: this.extractTimeline(response),
            resources: this.extractResourceRequirements(response),

            // ÂÖÉÊï∞ÊçÆ
            rawStrategy: response,
            contextUsed: context
        };
    }

    private extractContentGaps(text: string): string[] {
        const section = this.extractSection(text, 'ÂÜÖÂÆπÂ∑ÆË∑ùÂàÜÊûê');
        return this.extractListItems(section);
    }

    private extractPriorityMatrix(text: string): any {
        const section = this.extractSection(text, 'ÂÜÖÂÆπ‰ºòÂÖàÁ∫ßÁü©Èòµ');
        return {
            quickWins: this.extractSubsectionItems(section, 'Âø´ÈÄüËÉúÂà©'),
            strategic: this.extractSubsectionItems(section, 'ÊàòÁï•ÊÄß'),
            timeline: this.extractSubsectionItems(section, 'Êó∂Èó¥Á∫ø')
        };
    }

    private extractAudienceSegmentation(text: string): any {
        const section = this.extractSection(text, 'Âèó‰ºóÁªÜÂàÜÁ≠ñÁï•');
        return {
            primaryAudience: this.extractSubsectionItems(section, '‰∏ªË¶ÅÂèó‰ºó'),
            preferences: this.extractSubsectionItems(section, 'ÂÜÖÂÆπÂÅèÂ•Ω'),
            personalization: this.extractSubsectionItems(section, '‰∏™ÊÄßÂåñ')
        };
    }

    private extractSEOStrategy(text: string): any {
        const section = this.extractSection(text, 'SEOÂíåÂèëÁé∞ÊÄß‰ºòÂåñ');
        return {
            keywords: this.extractSubsectionItems(section, 'ÂÖ≥ÈîÆËØç'),
            structure: this.extractSubsectionItems(section, 'ÁªìÊûÑ‰ºòÂåñ'),
            searchIntent: this.extractSubsectionItems(section, 'ÊêúÁ¥¢ÊÑèÂõæ')
        };
    }

    private extractConversionPath(text: string): any {
        const section = this.extractSection(text, 'ËΩ¨ÂåñË∑ØÂæÑËÆæËÆ°');
        return {
            userJourney: this.extractSubsectionItems(section, 'Áî®Êà∑ÊóÖÁ®ã'),
            contentFunnel: this.extractSubsectionItems(section, 'ÂÜÖÂÆπÊºèÊñó'),
            ctaStrategy: this.extractSubsectionItems(section, 'CTAÁ≠ñÁï•')
        };
    }

    private extractContentFormats(text: string): string[] {
        const section = this.extractSection(text, 'ÂÜÖÂÆπÊ†ºÂºèÂíåÊ∏†ÈÅìÁ≠ñÁï•');
        return this.extractListItems(section);
    }

    private extractSection(text: string, sectionName: string): string {
        const regex = new RegExp(`${sectionName}[\\s\\S]*?(?=###|$)`, 'i');
        const match = text.match(regex);
        return match ? match[0] : '';
    }

    private extractSubsectionItems(text: string, subsectionName: string): string[] {
        const regex = new RegExp(`${subsectionName}[\\s\\S]*?(?=-|$)`, 'i');
        const match = text.match(regex);
        if (!match) return [];

        return this.extractListItems(match[0]);
    }

    private extractListItems(text: string): string[] {
        const lines = text.split('\n');
        return lines
            .filter(line => line.trim().match(/^[-*‚Ä¢]\s+/))
            .map(line => line.replace(/^[-*‚Ä¢]\s+/, '').trim())
            .filter(item => item.length > 0);
    }

    private analyzeDocumentTypes(files: any[]): Record<string, number> {
        const types: Record<string, number> = {};
        files.forEach(file => {
            types[file.category] = (types[file.category] || 0) + 1;
        });
        return types;
    }

    private assessContentQuality(files: any[]): number {
        if (files.length === 0) return 0;

        const avgPriority = files.reduce((sum, file) => sum + file.priority, 0) / files.length;
        const avgTokens = files.reduce((sum, file) => sum + file.tokenCount, 0) / files.length;

        // Âü∫‰∫é‰ºòÂÖàÁ∫ßÂíåÂÜÖÂÆπÈïøÂ∫¶ËØÑ‰º∞Ë¥®Èáè
        return Math.round((avgPriority * 0.7) + (Math.min(avgTokens / 100, 30) * 0.3));
    }

    private assessTechnicalDepth(files: any[]): number {
        const technicalCategories = ['api', 'docs', 'config'];
        const technicalFiles = files.filter(file => technicalCategories.includes(file.category));

        if (files.length === 0) return 0;

        const technicalRatio = technicalFiles.length / files.length;
        const avgTechnicalPriority = technicalFiles.length > 0
            ? technicalFiles.reduce((sum, file) => sum + file.priority, 0) / technicalFiles.length
            : 0;

        return Math.round((technicalRatio * 50) + (avgTechnicalPriority * 0.5));
    }

    private generateActionPlan(text: string): string[] {
        // ‰ªéÁ≠ñÁï•ÊñáÊú¨‰∏≠ÊèêÂèñÂèØÊâßË°åÁöÑË°åÂä®È°π
        const lines = text.split('\n');
        return lines
            .filter(line => line.includes('Âª∫ËÆÆ') || line.includes('Â∫îËØ•') || line.includes('ÈúÄË¶Å'))
            .map(line => line.trim())
            .slice(0, 8);
    }

    private extractTimeline(text: string): string[] {
        const timelineSection = this.extractSection(text, 'Êó∂Èó¥Á∫ø');
        return this.extractListItems(timelineSection);
    }

    private extractResourceRequirements(text: string): string[] {
        // ÊèêÂèñËµÑÊ∫êÈúÄÊ±Ç
        const lines = text.split('\n');
        return lines
            .filter(line => line.includes('ËµÑÊ∫ê') || line.includes('‰∫∫Âëò') || line.includes('Â∑•ÂÖ∑'))
            .map(line => line.trim())
            .slice(0, 5);
    }

    private calculateStrategyConfidence(strategy: any): number {
        let confidence = 65; // Âü∫Á°ÄÁΩÆ‰ø°Â∫¶

        if (strategy.contentGaps.length > 2) confidence += 10;
        if (strategy.priorityMatrix.quickWins.length > 0) confidence += 8;
        if (strategy.seoStrategy.keywords.length > 0) confidence += 7;
        if (strategy.conversionPath.userJourney.length > 0) confidence += 5;
        if (strategy.contextInsights.contentQuality > 60) confidence += 5;

        return Math.min(90, confidence);
    }
}

// üìù Â¢ûÂº∫ÂÜÖÂÆπÁîüÊàêAgent
export class EnhancedContentGeneratorAgent extends BaseAgent {
    private contextSelector: ContextSelector;

    constructor() {
        super(
            'EnhancedContentGenerator',
            'Advanced Marketing Content Creator',
            'Generate superior marketing content using comprehensive project context and intelligent document selection',
            `Elite copywriter with access to complete project documentation and context.
            Specializes in creating compelling, technically accurate content that resonates
            with developer audiences while maintaining high conversion potential.`
        );

        this.contextSelector = new ContextSelector();
    }

    async execute(input: any, context: AgentContext): Promise<AgentResult> {
        try {
            const {
                projectAnalysis,
                contentStrategy,
                contentType = 'marketing-content',
                targetAudience = 'developers and technical teams',
                tone = 'professional yet approachable'
            } = input;

            // ‰∏∫ÁâπÂÆöÂÜÖÂÆπÁ±ªÂûãÈÄâÊã©ÊúÄ‰Ω≥‰∏ä‰∏ãÊñá
            const selectedContext = this.contextSelector.selectContext(projectAnalysis, contentType as AITaskType);

            // ÁîüÊàêÂ¢ûÂº∫ÁöÑÂÜÖÂÆπÁîüÊàêÊèêÁ§∫
            const prompt = this.generateEnhancedContentPrompt(
                projectAnalysis,
                contentStrategy,
                selectedContext,
                contentType,
                targetAudience,
                tone
            );

            const response = await this.callLLM(prompt, context);
            const content = this.parseEnhancedContent(response, selectedContext, contentType);

            return {
                success: true,
                data: content,
                metadata: {
                    executionTime: 0,
                    confidence: this.calculateContentQuality(content),
                    contextDocuments: selectedContext.selectedFiles.length,
                    totalTokens: selectedContext.totalTokens,
                    contentType,
                    targetAudience,
                    tone
                }
            };

        } catch (error) {
            return {
                success: false,
                data: null,
                error: error instanceof Error ? error.message : 'Enhanced content generation failed'
            };
        }
    }

    private generateEnhancedContentPrompt(
        projectAnalysis: EnhancedProjectAnalysis,
        contentStrategy: any,
        selectedContext: SelectedContext,
        contentType: string,
        targetAudience: string,
        tone: string
    ): string {
        const projectInfo = selectedContext.structured;
        const documentContext = selectedContext.selectedFiles
            .slice(0, 5) // ÈôêÂà∂ÊúÄÈáçË¶ÅÁöÑ5‰∏™ÊñáÊ°£
            .map(file => `### ${file.category.toUpperCase()}: ${file.path}\n${file.content}`)
            .join('\n\n---\n\n');

        return `
# Â¢ûÂº∫Ëê•ÈîÄÂÜÖÂÆπÁîüÊàê‰ªªÂä°

## È°πÁõÆÊ†∏ÂøÉ‰ø°ÊÅØ
**ÂêçÁß∞**: ${projectInfo?.metadata.name}
**ÊèèËø∞**: ${projectInfo?.metadata.description}
**ÁâàÊú¨**: ${projectInfo?.metadata.version}
**ÊäÄÊúØÊ†à**: ${projectInfo?.techStack.map(t => `${t.language}${t.framework ? ` (${t.framework})` : ''}`).join(', ')}
**ÂÖ≥ÈîÆËØç**: ${projectInfo?.metadata.keywords.join(', ')}

## ÂÜÖÂÆπÁ≠ñÁï•ÊåáÂØº
${contentStrategy ? JSON.stringify(contentStrategy, null, 2) : 'Êó†ÁâπÂÆöÁ≠ñÁï•ÊåáÂØº'}

## È°πÁõÆÊñáÊ°£‰∏ä‰∏ãÊñá
${selectedContext.selectionReason}

${documentContext}

## ÂÜÖÂÆπÁîüÊàêË¶ÅÊ±Ç

**ÂÜÖÂÆπÁ±ªÂûã**: ${contentType}
**ÁõÆÊ†áÂèó‰ºó**: ${targetAudience}
**ËØ≠Ë∞ÉÈ£éÊ†º**: ${tone}

### ÁîüÊàêÂÜÖÂÆπÁªìÊûÑË¶ÅÊ±ÇÔºö

1. **Âºï‰∫∫Ê≥®ÁõÆÁöÑÊ†áÈ¢ò**
   - Á™ÅÂá∫Ê†∏ÂøÉ‰ª∑ÂÄº‰∏ªÂº†
   - ÂåÖÂê´ÂÖ≥ÈîÆÊäÄÊúØÁâπÊÄß
   - Èù¢ÂêëÁõÆÊ†áÂèó‰ºó

2. **ÂâØÊ†áÈ¢òÂíåÁÆÄ‰ªã**
   - Êâ©Â±ï‰ª∑ÂÄº‰∏ªÂº†
   - Ëß£ÈáäËß£ÂÜ≥ÁöÑÈóÆÈ¢ò
   - Âª∫Á´ãÊäÄÊúØÂèØ‰ø°Â∫¶

3. **Ê†∏ÂøÉÂäüËÉΩ‰∫ÆÁÇπ**
   - Âü∫‰∫éÂÆûÈôÖÈ°πÁõÆÂäüËÉΩ
   - Á™ÅÂá∫ÊäÄÊúØ‰ºòÂäø
   - ÂåÖÂê´ÂÖ∑‰ΩìÁ§∫‰æã

4. **ÊäÄÊúØ‰ª∑ÂÄº‰∏ªÂº†**
   - Ëß£ÂÜ≥ÁöÑÂºÄÂèëËÄÖÁóõÁÇπ
   - ÊäÄÊúØÂàõÊñ∞ÁÇπ
   - ‰∏éÁ´ûÂìÅÁöÑÂ∑ÆÂºÇÂåñ

5. **‰ΩøÁî®Âú∫ÊôØÂíåÊ°à‰æã**
   - ÂÆûÈôÖÂ∫îÁî®Âú∫ÊôØ
   - ÁõÆÊ†áÁî®Êà∑Â∑•‰ΩúÊµÅÈõÜÊàê
   - ÂÖ∑‰ΩìÊî∂ÁõäÈáèÂåñ

6. **Ë°åÂä®Âè∑Âè¨**
   - Ê∏ÖÊô∞ÁöÑ‰∏ã‰∏ÄÊ≠•ÊåáÂºï
   - Èôç‰Ωé‰ΩøÁî®Èó®Êßõ
   - Â§öÂ±ÇÊ¨°ËΩ¨ÂåñË∑ØÂæÑ

### ÂÜÖÂÆπË¥®ÈáèÊ†áÂáÜÔºö
- ÊäÄÊúØÂáÜÁ°ÆÊÄßÔºöÂü∫‰∫éÁúüÂÆûÈ°πÁõÆ‰ø°ÊÅØ
- Âèó‰ºóÁõ∏ÂÖ≥ÊÄßÔºöÁ¨¶ÂêàÂºÄÂèëËÄÖÈúÄÊ±ÇÂíåËØ≠Ë®Ä‰π†ÊÉØ
- ËΩ¨ÂåñÂØºÂêëÔºöÊØè‰∏™ÈÉ®ÂàÜÈÉΩÊúâÊòéÁ°ÆÁõÆÁöÑ
- SEOÂèãÂ•ΩÔºöËá™ÁÑ∂ËûçÂÖ•Áõ∏ÂÖ≥ÂÖ≥ÈîÆËØç
- ÂèØÊâ´ÊèèÊÄßÔºöÊ∏ÖÊô∞ÁöÑÁªìÊûÑÂíåÈáçÁÇπÁ™ÅÂá∫

### ËæìÂá∫Ê†ºÂºèÔºö
ËØ∑‰ª•MarkdownÊ†ºÂºèËæìÂá∫ÔºåÂåÖÂê´Ôºö
- ÂÆåÊï¥ÁöÑËê•ÈîÄÈ°µÈù¢ÂÜÖÂÆπ
- SEOÂÖÉÊï∞ÊçÆÂª∫ËÆÆ
- Á§æ‰∫§Â™í‰ΩìÊëòË¶ÅÁâàÊú¨
- ÂÖ≥ÈîÆÊ∂àÊÅØÊèêÂèñ

Á°Æ‰øùÂÜÖÂÆπÊó¢‰∏ì‰∏öÂèàÊòìÊáÇÔºåÊó¢ÊäÄÊúØÂáÜÁ°ÆÂèàÂÖ∑ÊúâËØ¥ÊúçÂäõ„ÄÇ
`;
    }

    private parseEnhancedContent(response: string, context: SelectedContext, contentType: string): any {
        return {
            // ‰∏ªË¶ÅÂÜÖÂÆπÁªÑ‰ª∂
            headline: this.extractHeadline(response),
            subheadline: this.extractSubheadline(response),
            introduction: this.extractIntroduction(response),
            features: this.extractFeatures(response),
            valueProposition: this.extractValueProposition(response),
            useCases: this.extractUseCases(response),
            callToAction: this.extractCallToAction(response),

            // SEOÂíåËê•ÈîÄÁªÑ‰ª∂
            seoMetadata: this.extractSEOMetadata(response),
            socialMediaSummary: this.extractSocialMediaSummary(response),
            keyMessages: this.extractKeyMessages(response),

            // Â¢ûÂº∫ÂàÜÊûê
            contentAnalysis: {
                technicalAccuracy: this.assessTechnicalAccuracy(response, context),
                audienceAlignment: this.assessAudienceAlignment(response),
                conversionPotential: this.assessConversionPotential(response),
                seoOptimization: this.assessSEOOptimization(response)
            },

            // ÂÆåÊï¥ÂÜÖÂÆπ
            fullMarkdownContent: this.extractFullMarkdown(response),

            // ÂÖÉÊï∞ÊçÆ
            generationContext: {
                contentType,
                documentsUsed: context.selectedFiles.length,
                totalTokens: context.totalTokens,
                contextStrategy: context.strategy.taskType
            },

            rawResponse: response
        };
    }

    private extractHeadline(text: string): string {
        // Êü•Êâæ‰∏ªÊ†áÈ¢ò
        const patterns = [
            /^#\s+(.+)$/m,
            /(?:Ê†áÈ¢ò|headline|title)[Ôºö:]\s*(.+)$/im,
            /^(.+)(?=\n[=-]{3,})/m
        ];

        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match && match[1].trim().length > 0) {
                return match[1].trim();
            }
        }

        return '';
    }

    private extractSubheadline(text: string): string {
        const patterns = [
            /^##\s+(.+)$/m,
            /(?:ÂâØÊ†áÈ¢ò|subheadline|subtitle)[Ôºö:]\s*(.+)$/im
        ];

        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match && match[1].trim().length > 0) {
                return match[1].trim();
            }
        }

        return '';
    }

    private extractIntroduction(text: string): string {
        // ÊèêÂèñ‰ªãÁªçÊÆµËêΩ
        const introSection = text.match(/(?:ÁÆÄ‰ªã|introduction|Ê¶ÇËø∞)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        return introSection ? introSection[1].trim() : '';
    }

    private extractFeatures(text: string): string[] {
        const featureSection = text.match(/(?:ÂäüËÉΩ|features|ÁâπÊÄß)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        if (!featureSection) return [];

        return this.extractListItems(featureSection[1]);
    }

    private extractValueProposition(text: string): string {
        const vpSection = text.match(/(?:‰ª∑ÂÄº‰∏ªÂº†|value proposition|Ê†∏ÂøÉ‰ª∑ÂÄº)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        return vpSection ? vpSection[1].trim() : '';
    }

    private extractUseCases(text: string): string[] {
        const useCaseSection = text.match(/(?:‰ΩøÁî®Âú∫ÊôØ|use cases|Â∫îÁî®Âú∫ÊôØ)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        if (!useCaseSection) return [];

        return this.extractListItems(useCaseSection[1]);
    }

    private extractCallToAction(text: string): string {
        const ctaSection = text.match(/(?:Ë°åÂä®Âè∑Âè¨|call to action|cta)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        return ctaSection ? ctaSection[1].trim() : '';
    }

    private extractSEOMetadata(text: string): any {
        const seoSection = text.match(/(?:SEO|ÂÖÉÊï∞ÊçÆ|metadata)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        if (!seoSection) return {};

        const content = seoSection[1];
        return {
            title: this.extractValue(content, 'title'),
            description: this.extractValue(content, 'description'),
            keywords: this.extractValue(content, 'keywords')?.split(',').map(k => k.trim()) || []
        };
    }

    private extractSocialMediaSummary(text: string): string {
        const socialSection = text.match(/(?:Á§æ‰∫§Â™í‰Ωì|social media|ÊëòË¶Å)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        return socialSection ? socialSection[1].trim() : '';
    }

    private extractKeyMessages(text: string): string[] {
        const keySection = text.match(/(?:ÂÖ≥ÈîÆÊ∂àÊÅØ|key messages|Ê†∏ÂøÉ‰ø°ÊÅØ)[Ôºö:]?\s*\n?([\s\S]*?)(?=\n##|\n###|$)/i);
        if (!keySection) return [];

        return this.extractListItems(keySection[1]);
    }

    private extractFullMarkdown(text: string): string {
        // Ê∏ÖÁêÜÂíåÊ†ºÂºèÂåñÂÆåÊï¥ÁöÑMarkdownÂÜÖÂÆπ
        return text
            .replace(/^#+ Â¢ûÂº∫Ëê•ÈîÄÂÜÖÂÆπÁîüÊàê‰ªªÂä°[\s\S]*?(?=^#[^#])/m, '') // ÁßªÈô§‰ªªÂä°ËØ¥Êòé
            .replace(/^## È°πÁõÆÊ†∏ÂøÉ‰ø°ÊÅØ[\s\S]*?(?=^#[^#])/m, '') // ÁßªÈô§È°πÁõÆ‰ø°ÊÅØ
            .trim();
    }

    private extractListItems(text: string): string[] {
        const lines = text.split('\n');
        return lines
            .filter(line => line.trim().match(/^[-*‚Ä¢]\s+/))
            .map(line => line.replace(/^[-*‚Ä¢]\s+/, '').trim())
            .filter(item => item.length > 0);
    }

    private extractValue(text: string, key: string): string {
        const regex = new RegExp(`${key}[Ôºö:][\\s]*([^\\n]+)`, 'i');
        const match = text.match(regex);
        return match ? match[1].trim() : '';
    }

    private assessTechnicalAccuracy(content: string, context: SelectedContext): number {
        // Âü∫‰∫é‰ΩøÁî®ÁöÑÊäÄÊúØÊñáÊ°£Êï∞ÈáèÂíåË¥®ÈáèËØÑ‰º∞ÊäÄÊúØÂáÜÁ°ÆÊÄß
        const technicalDocs = context.selectedFiles.filter(f =>
            ['api', 'docs', 'config'].includes(f.category)
        );

        let accuracy = 50; // Âü∫Á°ÄÂàÜÊï∞

        if (technicalDocs.length > 0) accuracy += 20;
        if (technicalDocs.length > 2) accuracy += 10;

        // Ê£ÄÊü•ÂÜÖÂÆπ‰∏≠ÊòØÂê¶ÂåÖÂê´ÊäÄÊúØÁªÜËäÇ
        const technicalTerms = ['API', 'framework', 'library', 'configuration', 'installation'];
        const mentionedTerms = technicalTerms.filter(term =>
            content.toLowerCase().includes(term.toLowerCase())
        );

        accuracy += mentionedTerms.length * 4;

        return Math.min(100, accuracy);
    }

    private assessAudienceAlignment(content: string): number {
        // ËØÑ‰º∞ÂÜÖÂÆπ‰∏éÂºÄÂèëËÄÖÂèó‰ºóÁöÑÂåπÈÖçÂ∫¶
        const developerTerms = ['developer', 'code', 'programming', 'development', 'technical', 'API', 'framework'];
        const professionalTone = ['efficient', 'reliable', 'scalable', 'maintainable', 'robust'];

        let alignment = 40;

        developerTerms.forEach(term => {
            if (content.toLowerCase().includes(term)) alignment += 5;
        });

        professionalTone.forEach(term => {
            if (content.toLowerCase().includes(term)) alignment += 3;
        });

        return Math.min(100, alignment);
    }

    private assessConversionPotential(content: string): number {
        // ËØÑ‰º∞ËΩ¨ÂåñÊΩúÂäõ
        const conversionElements = ['get started', 'try', 'download', 'install', 'learn more', 'documentation'];
        const benefitWords = ['save', 'improve', 'faster', 'easier', 'better', 'efficient'];

        let potential = 30;

        conversionElements.forEach(element => {
            if (content.toLowerCase().includes(element)) potential += 8;
        });

        benefitWords.forEach(word => {
            if (content.toLowerCase().includes(word)) potential += 4;
        });

        return Math.min(100, potential);
    }

    private assessSEOOptimization(content: string): number {
        // ËØÑ‰º∞SEO‰ºòÂåñÁ®ãÂ∫¶
        let seoScore = 20;

        // Ê£ÄÊü•Ê†áÈ¢òÁªìÊûÑ
        const headings = content.match(/^#{1,6}\s+/gm) || [];
        if (headings.length > 0) seoScore += 15;
        if (headings.length > 3) seoScore += 10;

        // Ê£ÄÊü•ÂÜÖÂÆπÈïøÂ∫¶
        const wordCount = content.split(/\s+/).length;
        if (wordCount > 300) seoScore += 15;
        if (wordCount > 600) seoScore += 10;

        // Ê£ÄÊü•ÂÖ≥ÈîÆËØçÂØÜÂ∫¶
        const techKeywords = ['AI', 'automation', 'developer', 'tool', 'extension'];
        techKeywords.forEach(keyword => {
            if (content.toLowerCase().includes(keyword.toLowerCase())) seoScore += 5;
        });

        return Math.min(100, seoScore);
    }

    private calculateContentQuality(content: any): number {
        let quality = 50;

        // Âü∫Á°ÄÂÜÖÂÆπÂÆåÊï¥ÊÄß
        if (content.headline) quality += 10;
        if (content.subheadline) quality += 8;
        if (content.features.length > 0) quality += 10;
        if (content.valueProposition) quality += 8;
        if (content.callToAction) quality += 6;

        // Â¢ûÂº∫ÂàÜÊûêÂàÜÊï∞
        quality += content.contentAnalysis.technicalAccuracy * 0.08;
        quality += content.contentAnalysis.audienceAlignment * 0.06;
        quality += content.contentAnalysis.conversionPotential * 0.05;
        quality += content.contentAnalysis.seoOptimization * 0.03;

        return Math.min(95, Math.round(quality));
    }
}
