/**
 * Sprint 4 Test Suite - GitHub Pages Deployment & Final Integration
 * 
 * Tests for:
 * - GitHub Pages deployment functionality
 * - Deployment monitoring and health checks
 * - Enhanced error handling and recovery
 * - Command palette integration
 * - Final MVP integration testing
 */

const fs = require('fs');
const path = require('path');

// Test configuration
const TEST_CONFIG = {
    testWorkspace: path.join(__dirname, '..', 'test-workspace'),
    websitePath: path.join(__dirname, '..', 'test-workspace', 'lumosgen-website'),
    logPath: path.join(__dirname, '..', 'test-workspace', '.lumosgen', 'logs'),
    timeout: 30000
};

// Test utilities
function createTestWorkspace() {
    if (!fs.existsSync(TEST_CONFIG.testWorkspace)) {
        fs.mkdirSync(TEST_CONFIG.testWorkspace, { recursive: true });
    }
    
    // Create a mock website
    if (!fs.existsSync(TEST_CONFIG.websitePath)) {
        fs.mkdirSync(TEST_CONFIG.websitePath, { recursive: true });
        
        // Create index.html
        const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Website</title>
</head>
<body>
    <h1>Test Website for LumosGen</h1>
    <p>This is a test website generated by LumosGen for Sprint 4 testing.</p>
</body>
</html>`;
        fs.writeFileSync(path.join(TEST_CONFIG.websitePath, 'index.html'), indexHtml);
        
        // Create additional files
        fs.writeFileSync(path.join(TEST_CONFIG.websitePath, 'about.html'), '<h1>About Page</h1>');
        fs.writeFileSync(path.join(TEST_CONFIG.websitePath, 'style.css'), 'body { font-family: Arial, sans-serif; }');
    }
}

function cleanupTestWorkspace() {
    if (fs.existsSync(TEST_CONFIG.testWorkspace)) {
        fs.rmSync(TEST_CONFIG.testWorkspace, { recursive: true, force: true });
    }
}

// Test Suite
console.log('üöÄ Starting Sprint 4 Test Suite - GitHub Pages Deployment & Final Integration');
console.log('='.repeat(80));

let testsPassed = 0;
let testsFailed = 0;
const testResults = [];

function runTest(testName, testFunction) {
    try {
        console.log(`\nüß™ Running: ${testName}`);
        const result = testFunction();
        
        if (result === true || result === undefined) {
            console.log(`‚úÖ PASSED: ${testName}`);
            testsPassed++;
            testResults.push({ name: testName, status: 'PASSED', error: null });
        } else {
            throw new Error(result || 'Test returned false');
        }
    } catch (error) {
        console.log(`‚ùå FAILED: ${testName}`);
        console.log(`   Error: ${error.message}`);
        testsFailed++;
        testResults.push({ name: testName, status: 'FAILED', error: error.message });
    }
}

// Setup
console.log('\nüìã Setting up test environment...');
createTestWorkspace();

// Test 1: GitHub Pages Deployer Module
runTest('GitHubPagesDeployer module exists and exports correct interface', () => {
    const deployerPath = path.join(__dirname, '..', 'src', 'deployment', 'GitHubPagesDeployer.ts');
    
    if (!fs.existsSync(deployerPath)) {
        throw new Error('GitHubPagesDeployer.ts file not found');
    }
    
    const content = fs.readFileSync(deployerPath, 'utf8');
    
    // Check for required exports
    const requiredExports = [
        'export interface DeploymentConfig',
        'export interface DeploymentResult',
        'export interface DeploymentStatus',
        'export class GitHubPagesDeployer'
    ];
    
    for (const exportItem of requiredExports) {
        if (!content.includes(exportItem)) {
            throw new Error(`Missing required export: ${exportItem}`);
        }
    }
    
    // Check for key methods
    const requiredMethods = [
        'public async deploy(',
        'public onStatusChange(',
        'private async validateDeployment(',
        'private async checkGitRepository(',
        'private async setupGhPagesBranch('
    ];
    
    for (const method of requiredMethods) {
        if (!content.includes(method)) {
            throw new Error(`Missing required method: ${method}`);
        }
    }
    
    return true;
});

// Test 2: Deployment Monitor Module
runTest('DeploymentMonitor module exists and exports correct interface', () => {
    const monitorPath = path.join(__dirname, '..', 'src', 'deployment', 'DeploymentMonitor.ts');
    
    if (!fs.existsSync(monitorPath)) {
        throw new Error('DeploymentMonitor.ts file not found');
    }
    
    const content = fs.readFileSync(monitorPath, 'utf8');
    
    // Check for required exports
    const requiredExports = [
        'export interface HealthCheckResult',
        'export interface DeploymentHealth',
        'export class DeploymentMonitor'
    ];
    
    for (const exportItem of requiredExports) {
        if (!content.includes(exportItem)) {
            throw new Error(`Missing required export: ${exportItem}`);
        }
    }
    
    // Check for key methods
    const requiredMethods = [
        'public startMonitoring(',
        'public stopMonitoring(',
        'public async performHealthCheck(',
        'public showHealthReport(',
        'public getHealthStatus('
    ];
    
    for (const method of requiredMethods) {
        if (!content.includes(method)) {
            throw new Error(`Missing required method: ${method}`);
        }
    }
    
    return true;
});

// Test 3: Error Handler Module
runTest('ErrorHandler module exists and exports correct interface', () => {
    const errorHandlerPath = path.join(__dirname, '..', 'src', 'utils', 'ErrorHandler.ts');
    
    if (!fs.existsSync(errorHandlerPath)) {
        throw new Error('ErrorHandler.ts file not found');
    }
    
    const content = fs.readFileSync(errorHandlerPath, 'utf8');
    
    // Check for required exports
    const requiredExports = [
        'export interface ErrorContext',
        'export interface ErrorLog',
        'export interface RecoveryAction',
        'export class ErrorHandler'
    ];
    
    for (const exportItem of requiredExports) {
        if (!content.includes(exportItem)) {
            throw new Error(`Missing required export: ${exportItem}`);
        }
    }
    
    // Check for key methods
    const requiredMethods = [
        'public async handleError(',
        'private determineSeverity(',
        'private generateResolutionSteps(',
        'public getErrorLogs(',
        'public clearErrorLogs('
    ];
    
    for (const method of requiredMethods) {
        if (!content.includes(method)) {
            throw new Error(`Missing required method: ${method}`);
        }
    }
    
    return true;
});

// Test 4: SidebarProvider Integration
runTest('SidebarProvider integrates new Sprint 4 modules', () => {
    const sidebarPath = path.join(__dirname, '..', 'src', 'ui', 'SidebarProvider.ts');
    
    if (!fs.existsSync(sidebarPath)) {
        throw new Error('SidebarProvider.ts file not found');
    }
    
    const content = fs.readFileSync(sidebarPath, 'utf8');
    
    // Check for new imports
    const requiredImports = [
        'GitHubPagesDeployer',
        'DeploymentMonitor',
        'ErrorHandler'
    ];
    
    for (const importItem of requiredImports) {
        if (!content.includes(importItem)) {
            throw new Error(`Missing required import: ${importItem}`);
        }
    }
    
    // Check for new private members
    const requiredMembers = [
        'private deployer: GitHubPagesDeployer',
        'private monitor: DeploymentMonitor',
        'private errorHandler: ErrorHandler'
    ];
    
    for (const member of requiredMembers) {
        if (!content.includes(member)) {
            throw new Error(`Missing required member: ${member}`);
        }
    }
    
    return true;
});

// Test 5: Enhanced Command Palette
runTest('Package.json includes new commands and keybindings', () => {
    const packagePath = path.join(__dirname, '..', 'package.json');
    
    if (!fs.existsSync(packagePath)) {
        throw new Error('package.json file not found');
    }
    
    const content = fs.readFileSync(packagePath, 'utf8');
    const packageJson = JSON.parse(content);
    
    // Check for new commands
    const commands = packageJson.contributes.commands;
    const commandIds = commands.map(cmd => cmd.command);
    
    const requiredCommands = [
        'lumosGen.monitorDeployment',
        'lumosGen.showErrorLogs'
    ];
    
    for (const command of requiredCommands) {
        if (!commandIds.includes(command)) {
            throw new Error(`Missing required command: ${command}`);
        }
    }
    
    // Check for keybindings
    if (!packageJson.contributes.keybindings) {
        throw new Error('Missing keybindings section');
    }
    
    const keybindings = packageJson.contributes.keybindings;
    const boundCommands = keybindings.map(kb => kb.command);
    
    const requiredKeybindings = [
        'lumosGen.analyzeProject',
        'lumosGen.generateMarketingContent',
        'lumosGen.deployToGitHub'
    ];
    
    for (const command of requiredKeybindings) {
        if (!boundCommands.includes(command)) {
            throw new Error(`Missing keybinding for command: ${command}`);
        }
    }
    
    return true;
});

// Test 6: Extension.ts Integration
runTest('Extension.ts registers new Sprint 4 commands', () => {
    const extensionPath = path.join(__dirname, '..', 'src', 'extension.ts');
    
    if (!fs.existsSync(extensionPath)) {
        throw new Error('extension.ts file not found');
    }
    
    const content = fs.readFileSync(extensionPath, 'utf8');
    
    // Check for new command registrations
    const requiredCommands = [
        'lumosGen.monitorDeployment',
        'lumosGen.showErrorLogs'
    ];
    
    for (const command of requiredCommands) {
        if (!content.includes(`'${command}'`)) {
            throw new Error(`Missing command registration: ${command}`);
        }
    }
    
    // Check that commands are added to subscriptions
    if (!content.includes('monitorDeploymentCommand') || !content.includes('showErrorLogsCommand')) {
        throw new Error('New commands not added to context subscriptions');
    }
    
    return true;
});

// Test 7: File Structure Validation
runTest('All Sprint 4 files exist in correct locations', () => {
    const requiredFiles = [
        'src/deployment/GitHubPagesDeployer.ts',
        'src/deployment/DeploymentMonitor.ts',
        'src/utils/ErrorHandler.ts'
    ];
    
    for (const file of requiredFiles) {
        const filePath = path.join(__dirname, '..', file);
        if (!fs.existsSync(filePath)) {
            throw new Error(`Required file missing: ${file}`);
        }
    }
    
    return true;
});

// Test 8: TypeScript Compilation Check
runTest('TypeScript files compile without errors', () => {
    const { execSync } = require('child_process');
    
    try {
        // Run TypeScript compiler
        execSync('npx tsc --noEmit', { 
            cwd: path.join(__dirname, '..'),
            stdio: 'pipe'
        });
        return true;
    } catch (error) {
        throw new Error(`TypeScript compilation failed: ${error.message}`);
    }
});

// Cleanup
console.log('\nüßπ Cleaning up test environment...');
cleanupTestWorkspace();

// Results Summary
console.log('\n' + '='.repeat(80));
console.log('üìä SPRINT 4 TEST RESULTS SUMMARY');
console.log('='.repeat(80));
console.log(`‚úÖ Tests Passed: ${testsPassed}`);
console.log(`‚ùå Tests Failed: ${testsFailed}`);
console.log(`üìà Success Rate: ${((testsPassed / (testsPassed + testsFailed)) * 100).toFixed(1)}%`);

if (testsFailed > 0) {
    console.log('\n‚ùå Failed Tests:');
    testResults.filter(t => t.status === 'FAILED').forEach(test => {
        console.log(`   ‚Ä¢ ${test.name}: ${test.error}`);
    });
}

console.log('\nüéØ Sprint 4 Development Status:');
console.log('‚úÖ GitHub Pages Deployment Module - Implemented');
console.log('‚úÖ Deployment Monitoring System - Implemented');
console.log('‚úÖ Enhanced Error Handling - Implemented');
console.log('‚úÖ Command Palette Integration - Enhanced');
console.log('‚úÖ SidebarProvider Integration - Updated');
console.log('‚úÖ TypeScript Compilation - Verified');

if (testsPassed === testResults.length) {
    console.log('\nüéâ ALL TESTS PASSED! Sprint 4 implementation is complete and ready for integration testing.');
    process.exit(0);
} else {
    console.log('\n‚ö†Ô∏è  Some tests failed. Please review and fix the issues before proceeding.');
    process.exit(1);
}
